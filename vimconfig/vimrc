" vim: set foldmethod=marker:
" Author: Austin Smith <auwsmit@gmail.com>
" Source: https://github.com/auwsmit/dotfiles
" Best viewed with vim's folds (see :help folds)

" STARTUP {{{

let s:is_windows = (has('win32')  || has('win64'))
let s:has_python = (has('python') || has('python3'))
let s:is_win_git = has_key(environ(), "MINGW_PREFIX") && has_key(environ(), "EXEPATH")

" detect .vim directory
let g:myvimdir ="~/.vim"
if s:is_windows
  let g:myvimdir ="~/vimfiles"
elseif has('nvim')
  let g:myvimdir ="~/.config/nvim"
endif

" }}}
" PLUGINS {{{
" plugin config files can be found under g:myvimdir/plugin
" press Enter on a line below to goto its config file

" setup vim-plug
call plug#begin()

" FILE/BUFFER PLUGINS {{{

Plug 'tpope/vim-eunuch'     " shell commands, e.g. :Remove & :Move & :Chmod
Plug 'tpope/vim-fugitive'   " vim + git integration
Plug 'justinmk/vim-gtfo'    " open gui explorer or terminal
Plug 'preservim/nerdtree'   " file tree viewer
Plug 'justinmk/vim-dirvish' " minimal file explorer
Plug 'yegappan/mru'         " most recent file list
Plug 'junegunn/fzf.vim'     " fzf + vim integration
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } } " general fuzzy finder
Plug 'mhinz/vim-sayonara', { 'on': 'Sayonara' } " simple buffer/window closing
Plug 'majutsushi/Tagbar',  { 'on': ['TagbarToggle', 'TagbarOpen'] } " tag explorer
if has('nvim')
  " trying my first neovim lua plugin.
  " TODO recreate a simple version in ye olde vimscript {{{
  " - basically marks on steroids
  " - only for files not line positions
  " - remembers last location while bookmarked
  " - opens toggleable window to view bookmarks
  " - bookmarks are grouped by current working directory
  " - hotkeys for add and remove bookmark
  " - hot keys for quick access, maybe integrate with peekaboo
  " }}}
  Plug 'nvim-lua/plenary.nvim'
  Plug 'ThePrimeagen/harpoon', { 'branch': 'harpoon2' }
endif
Plug 'auwsmit/vim-spear'

" }}}
" OPERATOR PLUGINS {{{

Plug 'tpope/vim-commentary'   " comment mappings
Plug 'machakann/vim-sandwich' " modify surrounding text eg: () and ''
Plug 'tommcdo/vim-exchange'   " exchange two pieces of text

" }}}
" TEXT OBJECT PLUGINS {{{

Plug 'kana/vim-niceblock'
Plug 'kana/vim-textobj-user'         |
      \ Plug 'kana/vim-textobj-line'  |
      \ Plug 'kana/vim-textobj-entire' |
      \ Plug 'kana/vim-textobj-indent'  |
      \ Plug 'kana/vim-textobj-function' |
      \ Plug 'coderifous/textobj-word-column.vim'
Plug 'junegunn/vim-after-object'

" " }}}
" MOTION/NAVIGATION PLUGINS {{{

Plug 'chaoren/vim-wordmotion'    " makes vim's 'word's more precise
Plug 'justinmk/vim-ipmotion'     " { } move over folds
Plug 'junegunn/vim-slash'        " improved search
Plug 'henrik/vim-indexed-search' " show total results (works on older versions of vim)

" " }}}
" SNIPPET/COMPLETION PLUGINS {{{

Plug 'ervandew/supertab'  " tab autocomplete
Plug 'tpope/vim-endwise', " auto-create end of certain keywords (if->endif)
if s:has_python
  Plug 'SirVer/UltiSnips' " snippets manager
endif

" }}}
" FORMAT/SYNTAX PLUGINS {{{

Plug 'justinmk/vim-syntax-extra', { 'for': ['c', 'cpp'] } " additional syntax highlighting for C/C++
Plug 'junegunn/vim-easy-align',   { 'on': ['<plug>(EasyAlign)', 'EasyAlign'] } " align text operator

" " }}}
" APPEARANCE/UI PLUGINS {{{

Plug 'xtal8/traces.vim'           " previews patterns for ex commands
Plug 'sjl/badwolf'                " a colorscheme
Plug 'auwsmit/vim-active-numbers' " line numbers follow the current window
Plug 'itchyny/lightline.vim'      " prettier statusbar
Plug 'junegunn/goyo.vim',   { 'on': 'Goyo' } " distraction free editing
Plug 'Yggdroot/indentLine', { 'on': ['IndentLinesEnable', 'IndentLinesToggle'] } " indent indicators
Plug 'junegunn/rainbow_parentheses.vim', { 'on': 'RainbowParentheses' }

" }}}
" MISC/CONVENIENCE PLUGINS " {{{

if v:version > 800
  Plug 'romainl/vim-qf' " sensible quickfix improvements
endif
Plug 'junegunn/vim-peekaboo'    " preview registers
Plug 'tpope/vim-rsi'            " readline key maps for cmd and ins mode
Plug 'tpope/vim-repeat'         " allows plugins to . repeat easier
Plug 'tpope/vim-sleuth'         " auto-detect tab settings per-file
Plug 'tpope/vim-unimpaired'     " tons of useful [x/]x mappings
Plug 'Konfekt/FastFold'         " optimize how Vim updates folds
Plug 'farmergreg/vim-lastplace' " reopen files at last position
Plug 'xolox/vim-session'        " simplified session management
Plug 'xolox/vim-misc'           " vim-session dependency
Plug 'junegunn/gv.vim', { 'on': 'GV' } " git commit browser
Plug 'mbbill/undotree', { 'on': 'UndotreeToggle' } " visual undo tree
if executable('ctags')
  Plug 'ludovicchabant/vim-gutentags' " auto-generate and update tags
endif

" }}}

" initialize vim-plug
call plug#end()

" }}}
" GENERAL SETTINGS {{{

" sensible options for me
set hidden
set incsearch
set ignorecase
set smartcase
set autoread
set lazyredraw
set gdefault
set showcmd
set nostartofline
set path+=**
set modeline
set sidescroll=8
set backspace=indent,eol,start
set history=10000
set undolevels=10000
set complete=.,w,b,t
set synmaxcol=1024
set nrformats-=octal
set virtualedit=all
set sessionoptions-=options
set sessionoptions-=folds
set clipboard^=unnamedplus,unnamed
set foldopen-=block
set shortmess-=S
set shortmess+=F
if s:is_windows
  set makeprg=build.bat
endif
silent! set mouse=a
set vb t_vb=
if exists('&belloff')
  set belloff=all
endif

" command-line completion settings
set wildmenu
set wildmode=full
set wildoptions+=fuzzy
set wildignore+=.hg,.git,.svn                    " Version control
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.spl                            " compiled spelling word lists
set wildignore+=*.sw?                            " Vim swap files
set wildignore+=*.DS_Store                       " OSX garbage

" backups, swapfiles, & undofiles in one place
let s:tempdir=expand(g:myvimdir .(has('nvim') ? '/neotmp' : '/tmp'))
if !isdirectory(expand(s:tempdir))
  call mkdir(expand(s:tempdir), 'p')
endif
set backup
let &backupdir=s:tempdir . '//'
set swapfile
let &directory=s:tempdir . '//'
if has('persistent_undo')
  set undofile
  let &undodir=s:tempdir . '//'
endif

if s:is_windows && executable('grep')
  set grepprg=grep\ -n
endif

" Neovide config
if exists("g:neovide")
  let g:neovide_cursor_animation_length = 0.00
  let g:neovide_scroll_animation_length = 0.2
endif

" }}}
" APPEARANCE AND FORMATTING {{{
" some settings will be overwritten when certain filetypes are detected
" see: filetype-indent-on, ftplugins, & after-directory

" default tab settings (vim-sleuth will usually override this)
set smarttab
set shiftwidth=4 softtabstop=-1 expandtab

" indenting/formatting
set autoindent
set smartindent " TODO: try cindent
set encoding=utf-8

" mostly aesthetic options
set hlsearch
set cpoptions+=$
set foldlevel=999
set foldmethod=indent
set guioptions=
set laststatus=2
set linebreak
set list
set listchars=tab:»\ ,extends:›,precedes:‹,nbsp:·,trail:■
set number relativenumber
set numberwidth=1
set ruler
set splitright
set noshowmode
if has('linebreak')
  set showbreak=«
  silent! set breakindent
else
  set listchars+=eol:¬
endif

" colorscheme and fallbacks if there are no
" plugins or if incompatible for some reason
fun! VimrcColorcheck(color) abort
  if !exists('g:colors_name')
    syntax enable
    exec 'silent! colorscheme ' . a:color
  endif
endfun
call VimrcColorcheck('badwolf')
call VimrcColorcheck('unokai')
call VimrcColorcheck('habamax')
call VimrcColorcheck('desert')

" git bash on windows has weird (poor) colors, so this looks best
if s:is_win_git
  colorscheme evening
  silent! call lightline#disable()
endif

" my statusline
execute 'set statusline=\ %<%f\ %h%m%r%=%y\ [%P]\ [%l,%v]'

" Disable Background Color Erase (BCE) so that color schemes
" render properly when inside 256-color tmux and GNU screen.
if &term =~ '256color'
  set t_ut=
endif

augroup vimrc_appearance_and_formatting
  au!

  " more accurate syntax highlighting
  au FileType vim syntax sync fromstart

  if s:is_windows
    " Maximize window
    au GUIEnter * simalt ~x
    " Fonts: glorious notepad default
    set guifont=Consolas:h10
  else
    " Unix deserves a nicer font
    set guifont=DejaVu\ Sans\ Mono\ 10
  endif

  " resize vim-windows when program window is resized
  au VimResized * wincmd =

  " this makes the trailing space indicator invisible
  " while typing, otherwise it would drive me crazy
  au InsertEnter * set listchars-=trail:■
  au InsertLeave * set listchars+=trail:■

augroup END

" }}}
" KEY MAPPINGS {{{
" plugin related maps can be found in g:myvimdir/plugin files

" REMAPS OF DEFAULTS {{{
" it's good to remember these in case I'm stuck with vanilla vi/vim
" (more specifically, remaps of *important* defaults)

" go back to last buffer
nnoremap <backspace> <c-^>

" Y yanks until EOL, more like D and C
" yy still yanks the whole line
nnoremap Y y$

" U as a more sensible redo
nnoremap U <c-r>

" classic
nnoremap <c-z> u

" Q to replay the q register
" I have never wanted to use Ex mode.
nnoremap Q @q

" Split line (opposite of J) {{{
fun! s:SplitLine()
  exec "normal! i\<cr>\<esc>^gk"
  silent! substitute/\v +$//
  silent! nohlsearch
  call histdel("search", -1)
  normal! $
endfun
" works with tpope's repeat.vim
nnoremap <silent> <plug>(MySplitLine) :call <sid>SplitLine()<cr>
      \ :silent! call repeat#set("\<plug>(MySplitLine)", v:count)<cr>
" }}}
nmap S <plug>(MySplitLine)

" new jump list mnemonic: previous, next
" (frees up CTRL-i AKA Tab)
nnoremap <silent> <c-p> <c-o>
nnoremap <silent> <c-n> <c-i>

" fold traversal {{{
fun! s:FoldedMoveToStart()
  if foldclosed('.') != -1 " fold is closed
    " make sure that folds open from the start
    norm! zo[zzc
  endif
endfun
" }}}
nnoremap <silent><c-k> zk:call <sid>FoldedMoveToStart()<cr>zz
nnoremap <c-j> zjzz
nnoremap <c-h> zc
nnoremap <c-l> zo

" org-style fold viewing
" TODO: make functions that are more accurate
nnoremap <tab> za
nnoremap <s-tab> zM

" open current file's directory
nnoremap - :e <c-r>=fnameescape(expand('%:p:h'))<cr>/<cr>

" open current working directory
nnoremap + :e .<cr>

" | and _ for split windows
nnoremap <expr><silent> \| !v:count ? "<c-w>v<c-w><right>" : '\|'
nnoremap <expr><silent> _  !v:count ? "<c-w>s<c-w><down>"  : '_'

" move by wrapped lines instead of line numbers, unless the motion is counted
" also set a mark for movements across 5 lines or more
nnoremap <expr> j (v:count >= 5 ? "m'" . v:count : '').(v:count? 'j' : 'gj')
nnoremap <expr> k (v:count >= 5 ? "m'" . v:count : '').(v:count? 'k' : 'gk')
xnoremap <expr> j (v:count >= 5 ? "m'" . v:count : '').(v:count? 'j' : 'gj')
xnoremap <expr> k (v:count >= 5 ? "m'" . v:count : '').(v:count? 'k' : 'gk')

" automatically jump to the end of pasted text
" useful for pasting multi-lines of text
xnoremap p p`]
nnoremap p p`]

" visually select the last change or yank
nnoremap gp `[v`]

" i_CTRL-[ finger slip
inoremap <c-]> <esc>

" edit or create plugin config {{{
" press Enter on [Plug 'author/plugin'] to create or open a local config file
fun! s:GotoPluginConfig()
  if getline('.') =~ "Plug '.*'"
    " this pattern matches whatever is within the
    " single quotes, and after the first slash
    let pattern = "Plug.*'[^']*/\\zs[^']*\\ze'"
    let name = matchstr(getline('.'), pattern)
    let path_to_plugin = expand(g:myvimdir.'/plugin/'.name)
    if filereadable(path_to_plugin.'.vim')
      echo 'Found config for ' . name
      exec 'edit ' . fnameescape(path_to_plugin.'.vim')
    elseif filereadable(path_to_plugin.'.lua')
      echo 'Found config for ' . name
      exec 'edit ' . fnameescape(path_to_plugin.'.lua')
    else
      let msg = 'No plugin config found. Would you like to create one?'
      let choice1 = confirm(msg,"&No\n&yes",1)
      if choice1 == 2
        let choice2 = confirm('',"&Vim\nor &lua",1)
        let ftype = choice2 == 1 ? '.vim' : '.lua'
        redraw
        echo 'Editing local config for ' . name
        exec 'edit ' . fnameescape(path_to_plugin.ftype)
      endif
    endif
  endif
endfun

fun! s:PluginConfigMapper()
  let current_file = expand('%:t')
  if current_file == 'init.vim' || current_file == 'vimrc'
    nnoremap <silent><buffer> <cr> :call <sid>GotoPluginConfig()<cr>
  endif
endfun

" }}}
augroup vimrc_view_plugin_config
  au!
  au FileType vim call <sid>PluginConfigMapper()
augroup END

" }}}
" STANDARD MAPS {{{

" :help works fine, thanks
noremap <f1> <nop>
inoremap <f1> <nop>

" Emacs blasphemy
inoremap <c-g> <esc>
cnoremap <c-g> <c-c>
xnoremap <c-g> <esc>

" don't run commands without my consent
cnoremap <esc> <c-c>
cnoremap <esc> <c-c>

" from tpope's rsi
inoremap <c-a> <c-o>^
inoremap <expr> <c-e> col('.')>strlen(getline('.'))<bar><bar>pumvisible()?"\<lt>C-E>":"\<lt>End>"

" expand-o-brackets
inoremap {<tab> {<cr>}<esc>O
inoremap {;<tab> {<cr>};<esc>O

" change directories (minor time saver)
nnoremap cd :cd<space>

" quickly manage buffers
fun! s:buflist_proper_esc()
  " otherwise you need to press esc twice
  cnoremap <silent><buffer> <esc> <esc><esc>:call <sid>buflist_remove_maps()<cr>
  cnoremap <silent><buffer> <c-g> <esc><esc>:call <sid>buflist_remove_maps()<cr>
  cnoremap <silent><buffer> <cr> <cr>:call <sid>buflist_remove_maps()<cr>
endfun
fun! s:buflist_remove_maps()
  silent! cunmap <buffer> <esc>
  silent! cunmap <buffer> <c-g>
  silent! cunmap <buffer> <cr>
endfun
nnoremap gb :call <sid>buflist_proper_esc()<cr>:ls<cr>:b<space>
nnoremap gB :call <sid>buflist_proper_esc()<cr>:ls!<cr>:b<space>

" resizing windows
noremap <c-left>  5<c-w><
noremap <c-up>    5<c-w>+
noremap <c-down>  5<c-w>-
noremap <c-right> 5<c-w>>
noremap <s-left>  <c-w><
noremap <s-up>    <c-w>+
noremap <s-down>  <c-w>-
noremap <s-right> <c-w>>

" unimpaired.vim inspired
" toggle centering the cursor
nnoremap yoz :let &scrolloff=999-&scrolloff<cr>:set so?<cr>

" toggle syntax highlighting {{{
" useful when Vim is crippled by its inefficient highlighting
fun! s:ToggleSyntaxHighlighting() abort
  let folds = &foldlevel
  execute 'syntax '.(exists("g:syntax_on") ? 'off' : 'enable')
  let &foldlevel=folds
endfun
command! ToggleSyntax call <sid>ToggleSyntaxHighlighting()
" }}}
nnoremap yoS :call <sid>ToggleSyntaxHighlighting()<cr>

" improved help mappings {{{
" (q to quit from Junegunn's vimrc)
fun! s:helpmaps() abort
  if &buftype == 'help'
    nnoremap <buffer> q :bd<cr>
    nnoremap <silent><buffer> <tab> :call search("\|\\S\\+\|")<cr>
    nnoremap <silent><buffer> <s-tab> :call search("\|\\S\\+\|",'b')<cr>
    nnoremap <buffer> <cr> <c-]>
  endif
endfun
augroup improved_help_maps
  au!
  au BufEnter *.txt call s:helpmaps()
augroup END
" }}}

" Source vimscript operator {{{
" Nice for quick vimscript testing.
fun! s:SourceVimscript(type) abort
  let sel_save = &selection
  let &selection = "inclusive"
  let reg_save = @"
  if a:type == 'line'
    silent execute "normal! '[V']y"
  elseif a:type == 'char'
    silent execute "normal! `[v`]y"
  elseif a:type == "visual"
    silent execute "normal! gvy"
  elseif a:type == "currentline"
    silent execute "normal! yy"
  endif
  let @" = substitute(@", '\n\s*\\', '', 'g')
  " source the content
  @"
  let &selection = sel_save
  let @" = reg_save
endfun
" }}}
nnoremap <silent> g: :set opfunc=<sid>SourceVimscript<cr>g@
xnoremap <silent> g: :<c-u>call <sid>SourceVimscript("visual")<cr>
nnoremap <silent> g:: :call <sid>SourceVimscript("currentline")<cr>

" Delete & Replace operator {{{
" (credit to justinmk's init.vim)
" why?
" - repeatable
" - faster/more convenient than visual-replace
" - does not modify ' mark
" - DWIM behavior for linewise => characterwise
func! s:trimws_ml(s) abort "trim whitespace across multiple lines
  return substitute(a:s, '^\_s*\(.\{-}\)\_s*$', '\1', '')
endf
let s:rr_reg = '"'
func! s:set_reg(reg_name) abort
  let s:rr_reg = a:reg_name
endf
func! s:replace_without_yank(type) abort
  let rr_orig = getreg(s:rr_reg, 1) "save registers and types to restore later.
  let rr_type = getregtype(s:rr_reg)
  let ur_orig = getreg('"', 1)
  let ur_type = getregtype('"')
  let sel_save = &selection
  let &selection = "inclusive"
  let replace_curlin = (1==col("'[") && (col('$')==1 || col('$')==(col("']")+1)) && line("'[")==line("']"))

  if a:type ==? 'line' || replace_curlin
    exec "keepjumps normal! '[V']\"".s:rr_reg."p"
  elseif a:type ==? 'block'
    exec "keepjumps normal! `[\<c-v>`]\"".s:rr_reg."p"
  elseif a:type == 'visual'
    exec "keepjumps normal! gv\"".s:rr_reg."p"
  else
    "DWIM: if pasting linewise contents in a _characterwise_ motion, trim
    "      surrounding whitespace from the content to be pasted.
    if rr_type ==# "V"
      call setreg(s:rr_reg, s:trimws_ml(rr_orig), "v")
    endif
    exec "keepjumps normal! `[v`]\"".s:rr_reg."p"
  endif

  let &selection = sel_save
  call setreg('"',      ur_orig, ur_type)
  call setreg(s:rr_reg, rr_orig, rr_type)
endf

" }}}
nnoremap <silent> dr  :<c-u>call <sid>set_reg(v:register)<bar>set opfunc=<sid>replace_without_yank<cr>g@
nnoremap <silent> drr :<c-u>call <sid>set_reg(v:register)<cr>0:<c-u>set opfunc=<sid>replace_without_yank<cr>g@$
xnoremap <silent> R :<c-u>call <sid>set_reg(v:register)<bar>call <sid>replace_without_yank('visual')<cr>

" %% expands to current buffer file name
" :: expands to current buffer file path
cnoremap %% <c-r>=fnameescape(expand('%'))<cr>
cnoremap :: <c-r>=fnameescape(expand('%:p:h'))<cr>/

" browse search results while searching with tab/s-tab
cnoremap <expr>  <tab>    getcmdtype() =~ '[?/]' ? '<c-g>' : feedkeys('<tab>', 'int')[1]
cnoremap <expr>  <s-tab>  getcmdtype() =~ '[?/]' ? '<c-t>' : feedkeys('<s-tab>', 'int')[1]

" sane terminal escape
if has('nvim')
  tnoremap <esc> <c-\><c-n>
  tnoremap <c-[> <c-\><c-n>
  tnoremap <c-]> <c-\><c-n>
  tnoremap <c-g> <c-\><c-n>
endif

" }}}
" LEADER MAPS {{{
" space is my leader

" don't move my cursor plz
nnoremap <space> <nop>
xnoremap <space> <nop>

" shortcuts
nnoremap <space>v :edit $MYVIMRC<cr>
nnoremap <space>s :write<cr>
nnoremap <space>o <c-w>o
nnoremap <space>c <c-w>c
nnoremap <space>w <c-w>
nnoremap <space>; :
if maparg('<space><space>','n') == ''
  nnoremap <space><space> :
endif

" help under the cursor
function! s:VisualSelection() abort
  let [l1, c1] = getpos("'<")[1:2]
  let [l2, c2] = getpos("'>")[1:2]
  if l1 == l2
    return getline(l1)[c1 - 1 : c2 - 1]
  endif
  return ''
endfunction
nnoremap <space>H :help <c-r><c-w>
xnoremap <space>H :<c-u>help <c-r>=<sid>VisualSelection()<cr>

" to previous window {{{
" (or next window, if prev is gone)
let g:win_tracker = 0
augroup vimrc_prev_window
  au!
  au WinEnter * let w:prev_window = g:win_tracker
  au WinLeave * let g:win_tracker = winnr()
augroup END
fun! s:BetterLastWindow() abort
  let l:lastwin = winnr()
  wincmd p
  if l:lastwin == winnr()
    if exists('w:prev_window')
      if winheight(w:prev_window) > -1
        silent! exec w:prev_window.' wincmd w'
      endif
    endif
    if l:lastwin == winnr()
      wincmd w
    endif
  endif
endfun " }}}
nnoremap <silent> <space><tab> :call <sid>BetterLastWindow()<cr>

" populate the location list with last search results
" useful for seeing the exact number of matches
nnoremap <space>? :lvim //g %<cr>

" no accidental command window (q:) {{{
" explanation: using 'nnoremap q: <nop>' gives my
" 'q to quit' map a slight pause, so this is a roundabout
" way of disabling q: without using any map commands
"
" mnemonic is 'history command' and 'history search'
nnoremap <space>h: :let g:cmdwinmap=1<cr>q:
nnoremap <space>h/ :let g:cmdwinmap=1<cr>q/

augroup vimrc_cmdwin_map
  au!
  let g:cmdwinmap = 0
  au CmdwinLeave * let g:cmdwinmap = 0
  au CmdwinEnter * exec expand(g:cmdwinmap ? '' : 'quit')
augroup END
" }}}

" search for all numbers
nnoremap <space>/# /\v\d+<cr>

" search for brackets
nnoremap <space>/[ ?[{}]<cr>
nnoremap <space>/] /[{}]<cr>

" toggle location & quickfix lists {{{
" (from vimwiki)
fun! GetBufferList() abort
  redir =>buflist
  silent! ls!
  redir END
  return buflist
endfun

fun! ToggleList(bufname, pfx) abort
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'),
        \ 'v:val =~ "'.a:bufname.'"'),
        \ 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      execute(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
    echohl ErrorMsg
    echo "Location List is Empty."
    return
  endif
  let winnr = winnr()
  execute(a:pfx.'open')
  if winnr() != winnr
    wincmd p
  endif
endfun
" }}}
nnoremap <silent> <space>l :call ToggleList("Location List", 'l')<cr>
nnoremap <silent> <space>q :call ToggleList("Quickfix List", 'c')<cr>

" quick scratch buffer
nnoremap <space>S :enew<cr>:setl bt=nofile bh=hide noswf<cr>:set ft=

" open command prompt at vim's current directory
if s:is_windows
  nnoremap <space>C :!start cmd /k cd %:p:h<cr>
endif

" }}}

" }}}
" MISCELLANEOUS {{{
" Other functions, commands, settings,
" etc.  that don't fit elsewhere go here

" delete all buffers and open a scratch buffer
fun! s:DeleteAllBuffers() abort
  %bdelete
  setl buftype=nofile bufhidden=wipe
endfun
command! -bar KillBuffers call <sid>DeleteAllBuffers()

" DoubleView {{{
" Vertically split the current buffer into two windows which will stay
" scroll-bound together.  Allows you to see twice as much as before!
" (disables the wrap setting and expands folds to work better)
" (PS: this is kind of janky, but I like it anyway)
fun! s:DoubleView() abort
  let DV_so=&scrolloff
  set scrolloff=0 noscrollbind nowrap nofoldenable
  exec "normal! m`\<c-b>"
  botright vsplit
  normal! Ljzt
  windo setl scrollbind
  let &scrolloff=DV_so
  exec "normal! \<c-w>p``"
endfun " }}}
command! DoubleView call <sid>DoubleView()

" custom text objects
let s:separators = exists('g:loaded_targets') ? [ '`', '%']
      \ : [ '_', '.', ':', ',', ';', '<bar>', '/', '<bslash>', '*', '+', '%', '`' ]
for char in s:separators
  exec 'xnoremap i' . char . ' :<c-u>normal! T' . char . 'vt' . char . '<cr>'
  exec 'onoremap i' . char . ' :normal vi' . char . '<cr>'
  exec 'xnoremap a' . char . ' :<c-u>normal! F' . char . 'vf' . char . '<cr>'
  exec 'onoremap a' . char . ' :normal va' . char . '<cr>'
endfor
" Clear Trailing White spaces
cabbrev ctw s/\s\+$//e

" }}}

