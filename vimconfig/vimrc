" vim: set foldmethod=marker:
" Author: Austin Smith <AssailantLF@gmail.com>
" Source: https://gitlab.com/AssailantLF/dotfiles
" Best viewed with vim's folds (see :help folds)

" ===========================================================================
" STARTUP {{{
" ===========================================================================

" Detect OS for OS-specific options
let s:is_cygwin = has('win32unix') || has('win64unix')
let s:is_mac = has('gui_macvim') || has('mac')
let s:is_windows = has('win32') || has('win64')
let s:is_nvim = has('nvim')

" detect .vim directory
let s:myvimdir ="~/.vim"
if s:is_windows
  let s:myvimdir ="~/vimfiles"
elseif s:is_nvim
  let s:myvimdir ="~/.config/nvim"
endif

let mapleader = "\<Space>"
let maplocalleader = "\\"

" }}}
" ===========================================================================
" PLUGINS {{{
" ===========================================================================
" vim-plug is the package manager

call plug#begin()

" ---------------------------------------------------------------------------
" FILE/BUFFER PLUGINS {{{
" ---------------------------------------------------------------------------

Plug 'tpope/vim-eunuch'

Plug 'tpope/vim-fugitive'
" Fugitive Settings {{{
nnoremap <Leader>gs :Gstatus<CR>
nnoremap <Leader>gd :Gdiff<CR>
nnoremap <Leader>gD :Gdiff HEAD<CR>
nnoremap <Leader>gc :Gcommit<CR>
nnoremap <Leader>gl :Git log<CR>
nnoremap <Leader>gp :Git push<CR>
nnoremap <Leader>gw :Gwrite<CR>
nnoremap <Leader>gg :Ggrep<Space>

" hide fugitive buffers to reduce buffer list clutter
augroup vimrc_fugitive
  au!
  au BufReadPost fugitive://* set bufhidden=delete
augroup END
" }}}

Plug 'justinmk/vim-gtfo'
" gtfo.vim Settings {{{
let g:gtfo#terminals = { 'win' : 'C:\WINDOWS\system32\cmd.exe /k' }
" }}}

Plug 'justinmk/vim-dirvish'
" Dirvish Settings {{{

" disable netrw
let g:loaded_netrw = 1
let g:loaded_netrwPlugin = 1

" open current file's directory
nnoremap <silent> - :Dirvish %<CR>
" open current working directory
nnoremap <silent> + :Dirvish<CR>
augroup my_dirvish_events
  au!
  " map gh to hide "hidden" files. (Unix only)
  au FileType dirvish nnoremap <buffer> gh
        \ :g@\v/\.[^\/]+/?$@d<CR>
  au FileType dirvish set nobuflisted
augroup END
" }}}

Plug 'ctrlpvim/ctrlp.vim' ", { 'on': ['CtrlP', 'CtrlPMRU', 'CtrlPBuffer', 'CtrlPLine'] }
" CtrlP Settings {{{

" ignore .git folders to speed up searches
let g:ctrlp_user_command = ['.git/', 'git --git-dir=%s/.git ls-files -oc --exclude-standard']
let g:ctrlp_max_depth = 15
" include hidden files
let g:ctrlp_show_hidden = 1
" open multiple files in ONE window
let g:ctrlp_open_multiple_files = '1vr'
" ctrl-o to open specifically
let g:ctrlp_arg_map = 1
" change default CtrlP mapping
let g:ctrlp_map = '<Leader>p'

" free <Space> in operator mode
augroup CtrlPLeader
  au! VimEnter * ounmap <Leader>p
augroup END

" shortcuts
nnoremap <Leader>p :CtrlP<CR>
nnoremap <Leader>b :CtrlPBuffer<CR>
nnoremap <Leader>- :CtrlPCurFile<CR>
nnoremap <Leader>+ :CtrlPCurWD<CR>
nnoremap <Leader><C-R> :CtrlPMRU<CR>
nnoremap <Leader><C-L> :CtrlPLine<CR>
nnoremap <Leader><C-P> :CtrlP<Space>
" }}}

Plug 'mhinz/vim-sayonara', { 'on': 'Sayonara' }
" Sayonara Settings {{{
" close buffer
nnoremap gs :Sayonara<CR>
" close buffer, don't close window
nnoremap gS :Sayonara!<CR>
" prompt to close vim when closing the last file
let g:sayonara_confirm_quit = 1
" see: 'q to quit help' under KEY MAPPINGS/NORMAL MAPS
function! s:helpquit()
  if &buftype == 'help'
    nnoremap <buffer> q :Sayonara<CR>
  endif
endfunction
augroup q_for_quit
  au!
  au BufEnter *.txt call s:helpquit()
augroup END
" }}}

" }}}
" ---------------------------------------------------------------------------
" OPERATOR PLUGINS {{{
" ---------------------------------------------------------------------------

Plug 'tpope/vim-commentary'

Plug 'machakann/vim-sandwich' " (tpope surround alternative)
" vim-sandwich Settings {{{
" mappings like tpope's surround plugin
let g:sandwich_no_default_key_mappings = 1
let g:operator_sandwich_no_default_key_mappings = 1
augroup SandwichSurround
  au! VimEnter * runtime macros/sandwich/keymap/surround.vim
augroup END
" }}}

Plug 'tommcdo/vim-exchange'
" vim-exchange Settings {{{
" evil-exchange bindings
nmap gxx <Plug>(ExchangeLine)
nmap gX  <Plug>(ExchangeClear)
nmap gx  <Plug>(Exchange)
xmap gx  <Plug>(Exchange)
" }}}

" }}}
" ---------------------------------------------------------------------------
" TEXT OBJECT PLUGINS {{{
" ---------------------------------------------------------------------------

"Plug 'machakann/vim-sandwich' " repeated: sandwich also has text objects

Plug 'kana/vim-textobj-user' |
      \ Plug 'kana/vim-textobj-line' |
      \ Plug 'kana/vim-textobj-entire'   |
      \ Plug 'kana/vim-textobj-indent'   |
      \ Plug 'kana/vim-textobj-function' |
      \ Plug 'coderifous/textobj-word-column.vim'

" }}}
" ---------------------------------------------------------------------------
" MOTION/NAVIGATION PLUGINS {{{
" ---------------------------------------------------------------------------

Plug 'chaoren/vim-wordmotion'

Plug 'justinmk/vim-ipmotion'
" ipmotion Settings {{{
" Skip over closed folds with { and }
let g:ip_skipfold = 1
"}}}

" Plug 'haya14busa/incsearch.vim'
" " incsearch.vim Settings {{{

" " default mappings
" map /  <Plug>(incsearch-forward)
" map ?  <Plug>(incsearch-backward)
" map g/ <Plug>(incsearch-stay)

" " auto nohlsearch (also center and open folds)
" let g:incsearch#auto_nohlsearch = 1
" map n  <Plug>(incsearch-nohl-n)zzzv
" map N  <Plug>(incsearch-nohl-N)zzzv
" map *  <Plug>(incsearch-nohl-*)zzzv
" map #  <Plug>(incsearch-nohl-#)zzzv
" map g* <Plug>(incsearch-nohl-g*)zzzv
" map g# <Plug>(incsearch-nohl-g#)zzzv
" augroup incsearch-keymap
"   autocmd!
"   autocmd VimEnter * IncSearchNoreMap <CR> <CR>zz
" augroup END
" " }}}

Plug 'junegunn/vim-slash' | Plug 'henrik/vim-indexed-search'
" vim-indexed-search Settings {{{
" no mappings
let g:indexed_search_mappings = 0
" vim-slash and indexed-search: UNITE!!!
noremap <Plug>(slash-after) :ShowSearchIndex<CR>
" }}}


Plug 'majutsushi/Tagbar',  { 'on': 'TagbarToggle' }
" Tagbar Settings {{{
nnoremap <Leader>t :TagbarToggle<CR>
" }}}

" }}}
" ---------------------------------------------------------------------------
" SNIPPET/COMPLETION PLUGINS {{{
" ---------------------------------------------------------------------------

Plug 'SirVer/UltiSnips', { 'on': 'UltiSnipsLoad' }
" UltiSnips Settings {{{
" this seems to somehow decrease load time
" idk maybe it's magic
augroup UltiSnipsAutoload
  au! VimEnter * silent! UltiSnipsLoad
augroup END
" }}}

Plug 'ervandew/supertab'

Plug 'tpope/vim-endwise',
      \ { 'for': [ 'vim', 'c', 'cpp', 'lua', 'ruby', 'sh', 'zsh', 'snippets' ] }

" }}}
" ---------------------------------------------------------------------------
" FORMAT/SYNTAX PLUGINS {{{
" ---------------------------------------------------------------------------

Plug 'junegunn/gv.vim',    { 'on': 'GV' }

Plug 'justinmk/vim-syntax-extra', { 'for': ['c', 'cpp'] }

Plug 'junegunn/vim-easy-align',   { 'on': ['<Plug>(EasyAlign)', 'EasyAlign'] }
" vim-easy-align Settings {{{
" Start interactive EasyAlign in visual mode (e.g. vipga)
vmap ga <Plug>(EasyAlign)
" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)
" }}}

" }}}
" ---------------------------------------------------------------------------
" APPEARANCE/UI PLUGINS {{{
" ---------------------------------------------------------------------------

Plug 'gcavallanti/vim-noscrollbar'

Plug 'AssailantLF/vim-active-numbers' " My plugin <3

Plug 'machakann/vim-highlightedyank'
" vim-highlightedyank Settings {{{
map y <Plug>(highlightedyank)
" colorscheme independent highlight
augroup CustomHighlightYankRegion
  au! VimEnter * hi HighlightedyankRegion cterm=reverse gui=reverse
augroup END
" }}}

Plug 'itchyny/lightline.vim'
" lightline Settings {{{
nnoremap <silent> <Leader>L }:exec lightline#toggle()<CR>``

" compatibility with other plugins {{{
let g:lightline = {
      \ 'colorscheme': 'powerline',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
      \   'right': [ [ 'syntastic', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
      \ },
      \ 'component_function': {
      \   'fugitive': 'LightLineFugitive',
      \   'filename': 'LightLineFilename',
      \   'fileformat': 'LightLineFileformat',
      \   'filetype': 'LightLineFiletype',
      \   'fileencoding': 'LightLineFileencoding',
      \   'mode': 'LightLineMode',
      \   'ctrlpmark': 'CtrlPMark',
      \ },
      \ 'component_expand': {
      \   'syntastic': 'SyntasticStatuslineFlag',
      \ },
      \ 'component_type': {
      \   'syntastic': 'error',
      \ },
      \ 'subseparator': { 'left': '|', 'right': '|' }
      \ }

let g:lightline.component = { 'percent': '%{noscrollbar#statusline()}' }

function! LightLineModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! LightLineReadonly()
  return &ft !~? 'help' && &readonly ? 'RO' : ''
endfunction

function! LightLineFilename()
  let fname = expand('%:t')
  return fname == 'ControlP' ? g:lightline.ctrlp_item :
        \ fname == '__Tagbar__' ? g:lightline.fname :
        \ fname =~ '__Gundo\|NERD_tree' ? '' :
        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        \ &ft == 'unite' ? unite#get_status_string() :
        \ &ft == 'vimshell' ? vimshell#get_status_string() :
        \ ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
endfunction

function! LightLineFugitive()
  try
    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
      let mark = ''  " edit here for cool mark
      let _ = fugitive#head()
      return strlen(_) ? mark._ : ''
    endif
  catch
  endtry
  return ''
endfunction

function! LightLineFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! LightLineFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! LightLineFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! LightLineMode()
  let fname = expand('%:t')
  return fname == '__Tagbar__' ? 'Tagbar' :
        \ fname == 'ControlP' ? 'CtrlP' :
        \ fname == '__Gundo__' ? 'Gundo' :
        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! CtrlPMark()
  if expand('%:t') =~ 'ControlP'
    call lightline#link('iR'[g:lightline.ctrlp_regex])
    return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
          \ , g:lightline.ctrlp_next], 0)
  else
    return ''
  endif
endfunction

let g:ctrlp_status_func = {
      \ 'main': 'CtrlPStatusFunc_1',
      \ 'prog': 'CtrlPStatusFunc_2',
      \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
  return lightline#statusline(0)
endfunction

let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
  let g:lightline.fname = a:fname
  return lightline#statusline(0)
endfunction
" }}}}
" }}}

Plug 'junegunn/goyo.vim',   { 'on': 'Goyo' }
" Goyo Settings {{{
" toggle Goyo (distraction free editing)
nnoremap <Leader>G :Goyo<CR>
" }}}

Plug 'junegunn/rainbow_parentheses.vim', { 'on': 'RainbowParentheses' }
" Rainbow Parenthesis Settings {{{
augroup rainbow_filetypes
  au!
  au FileType c,cpp,vim,sh,dosbatch,lisp RainbowParentheses
augroup END
" }}}

Plug 'Yggdroot/indentLine', { 'on': 'IndentLinesEnable' }
" indentLine Settings {{{
nnoremap <Leader>i :IndentLinesToggle<CR>
" use custom filetype detection for better vim-plug compatibility
let g:indentLine_enabled = 0
let g:indentLine_fileType = ['']
augroup ft_indentLine
  au!
  au FileType c,cpp IndentLinesEnable
augroup END
" }}}

if s:is_windows
  Plug 'kkoenig/wimproved.vim'
  " wimproved.vim Settings {{{
  " toggle fullscreen
  nnoremap <F11> :WToggleFullscreen<CR>
  " Fix GVim's ugly window border
  augroup Wimproved
    au!
    au GUIEnter * WToggleClean
  augroup END
endif
" }}}

" }}}
" ---------------------------------------------------------------------------
" CONVENIENCE/MISC PLUGINS " {{{
" ---------------------------------------------------------------------------

Plug 'tpope/vim-rsi'

Plug 'tpope/vim-repeat'

Plug 'tpope/vim-sleuth'

Plug 'tpope/vim-unimpaired'

Plug 'Konfekt/FastFold'

Plug 'dietsche/vim-lastplace'

Plug 'ludovicchabant/vim-gutentags'
" gutentags Settings {{{
let g:gutentags_enabled = 0
" }}}

Plug 'mhinz/vim-Startify'
" Startify Settings {{{
augroup startify_maps
  au!
  au User Startified setlocal relativenumber number
augroup END
let g:ctrlp_reuse_window = 'startify'
let g:startify_files_number = 6
let g:startify_session_delete_buffers = 1
let g:startify_session_persistence = 1
" }}}

Plug 'mbbill/undotree',    { 'on': 'UndotreeToggle' }
" undotree Settings {{{
nnoremap <Leader>u :UndotreeToggle<CR>
function! g:Undotree_CustomMap()
  nunmap <buffer> <Tab>
endfunction
" }}}

" Plug 'AndrewRadev/switch.vim'

" Plug 'AndrewRadev/splitjoin.vim',
"       \ { 'for': [ 'vim', 'c', 'cpp', 'lua', 'python', 'ruby', 'go' ] }

" Plug 'mhinz/vim-grepper'

" }}}
" ---------------------------------------------------------------------------

call plug#end()

" }}}
" ===========================================================================
" GENERAL SETTINGS {{{
" ===========================================================================

" sensible options for me
set hidden
set incsearch
set ignorecase
set smartcase
set autoread
set nolazyredraw
set gdefault
set showcmd
set nostartofline
set path+=**
set modeline
set sidescroll=8
set backspace=indent,eol,start
set history=10000
set undolevels=10000
set complete=.,w,b,t
set synmaxcol=1024
set nrformats-=octal
set fileformat=unix
set virtualedit=all
set sessionoptions-=options
set sessionoptions-=folds
set clipboard^=unnamedplus,unnamed
if s:is_windows
  set makeprg=build.bat
endif
silent! set mouse=a
set vb t_vb=
if exists('&belloff')
  set belloff=all
endif

" command-line completion settings
set wildmenu
set wildmode=full
set wildignore+=.hg,.git,.svn                    " Version control
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.spl                            " compiled spelling word lists
set wildignore+=*.sw?                            " Vim swap files
set wildignore+=*.DS_Store                       " OSX garbage

" backups, swapfiles, & undofiles in one place
let s:tempdir=expand(s:myvimdir."/tmp")
if !isdirectory(expand(s:tempdir))
  call mkdir(expand(s:tempdir), "p")
endif
set backup
let &backupdir=s:tempdir
set swapfile
let &directory=s:tempdir
if has('persistent_undo')
  set undofile
  let &undodir=s:tempdir
endif

if s:is_windows && executable('grep')
  set grepprg=grep\ -n
endif

" autocmds
augroup vimrc_general
  au!

  " make 'nobuflisted' persist when editing a file
  if (v:version > 704) || (v:version == 704 && has('patch786'))
    function! s:PersistNobl(type)
      if a:type == 'option'
        if &buflisted && exists('b:persist_nobl')
          unlet b:persist_nobl
        else
          let b:persist_nobl = 1
        endif
      elseif exists('b:persist_nobl')
        if b:persist_nobl
          setl nobuflisted
        endif
      endif
    endfunction
    au OptionSet buflisted call <SID>PersistNobl('option')
    au BufEnter * call <SID>PersistNobl('buf')
  endif

augroup END

" }}}
" ===========================================================================
" APPEARANCE AND FORMATTING {{{
" ===========================================================================
" some settings will be overwritten when certain filetypes are detected
" see: filetype-indent-on & ftplugins

" default tab settings
set smarttab
set shiftwidth=4 softtabstop=-1 expandtab

" indenting/formatting
set autoindent
set smartindent " TODO: try cindent
set textwidth=80
set encoding=utf-8

" mostly aesthetic options
set hlsearch
set cpoptions+=$
set foldlevel=999
set foldmethod=indent
set guioptions=
set laststatus=2
set linebreak
set list
set listchars=tab:»\ ,extends:›,precedes:‹,nbsp:·,trail:■
set nonumber relativenumber
set numberwidth=1
set ruler
set splitright
set t_Co=256
if has('linebreak')
  set showbreak=«
  silent! set breakindent
else
  set listchars+=eol:¬
endif

syntax on

" my 'modifed' version of Bad Wolf
silent! colorscheme badwolf_flattened

" fallback default colorscheme
if !exists('g:colors_name')
  colorscheme desert
endif

" standard status line if lightline isn't enabled
" (pretty much the same layout as default lightline)
set statusline=%<%f\ %h%m%r%=%y
if exists('g:noscrollbar_loaded')
  set statusline+=\ %{noscrollbar#statusline()}
else
  set statusline+=\ %P
endif
exe 'set statusline+=%8(%l,%v%)\ '

" Disable Background Color Erase (BCE) so that color schemes
" render properly when inside 256-color tmux and GNU screen.
if &term =~ '256color'
  set t_ut=
endif

augroup vimrc_appearance_and_formatting
  au!

  " I want these format options by default
  au FileType * set formatoptions=rq1j

  if s:is_windows
    " Maximize window
    au GUIEnter * simalt ~x
    " Fonts: glorious notepad default
    if s:is_nvim
      GuiFont Consolas:h9
    else
      set guifont=Consolas:h9
    endif
  else
    " Unix deserves a nicer font
    set guifont=DejaVu\ Sans\ Mono\ 9
  endif

  " resize vim-windows when program window is resized
  au VimResized * :wincmd =

  " this makes the trailing space indicator invisible
  " while typing, otherwise it would drive me crazy
  au InsertEnter * :set listchars-=trail:■
  au InsertLeave * :set listchars+=trail:■

augroup END

" }}}
" ===========================================================================
" KEY MAPPINGS {{{
" ===========================================================================
" anything related to plugins is located
" under its respective settings section

" ---------------------------------------------------------------------------
" REMAPS OF DEFAULTS {{{
" ---------------------------------------------------------------------------
" it's good to remember these in case I'm stuck with vanilla vi/vim

" disabled
noremap  <F1>    <Nop>
inoremap <F1>    <Nop>
noremap  <S-CR>  <Nop>
noremap  <Space> <Nop>
" for c<Space>
ounmap <Space>

" go back to last buffer
noremap <Backspace> <C-^>

" Y yanks until EOL, more like D and C
" yy still yanks the whole line
nmap Y y$

" U as a more sensible redo
nnoremap U <C-R>

" Q to replay the q register
" I have never wanted to use Ex mode.
nnoremap Q @q

" [S]plit lines (sister to [J]oin line) {{{
" cc still changes the whole line
function! s:SplitLine()
  exe "normal! i\<CR>\<Esc>^gk"
  silent! substitute/\v +$//
  silent! nohlsearch
  call histdel("search", -1)
  normal! $
endfunction
" }}}
nnoremap S :call <SID>SplitLine()<CR>

" center when jumping {{{
function! s:Center()
  let prev_so = &scrolloff
  set scrolloff=999
  redraw
  let &scrolloff = prev_so
endfunction
" }}}
" new jump list mnemonic: previous, next
nnoremap <silent> <C-P> <C-O>:call <SID>Center()<CR>
nnoremap <silent> <C-N> <C-I>:call <SID>Center()<CR>

" easier scrolling
nnoremap <C-J> <C-D>
nnoremap <C-K> <C-U>

" org-style fold viewing
nnoremap <Tab> za
nnoremap <S-Tab> zM

" going to the exact column is more useful most of the time
nnoremap ` '
nnoremap ' `

" open current file's directory
nnoremap - :e <C-R>=fnameescape(expand('%:p:h'))<CR>/<CR>

" open current working directory
nnoremap + :e .<CR>

" | and _ for split windows
nnoremap <expr><silent> \| !v:count ? "<C-W>v<C-W><Right>" : '\|'
nnoremap <expr><silent> _  !v:count ? "<C-W>s<C-W><Down>"  : '_'

" move by wrapped lines instead of line numbers, unless the motion is counted
" also set a mark for movements across 5 lines or more
nnoremap <expr> j (v:count >= 5 ? "m'" . v:count : '').(v:count? 'j' : 'gj')
nnoremap <expr> k (v:count >= 5 ? "m'" . v:count : '').(v:count? 'k' : 'gk')
vnoremap <expr> j (v:count >= 5 ? "m'" . v:count : '').(v:count? 'j' : 'gj')
vnoremap <expr> k (v:count >= 5 ? "m'" . v:count : '').(v:count? 'k' : 'gk')

" automatically jump to the end of pasted text
" useful for pasting multi-lines of text
xnoremap p p`]
nnoremap p p`]

" visually select the last change or yank
nnoremap gp `[v`]

" i_CTRL-[ finger slip
inoremap <C-]> <Esc>

" }}}
" ---------------------------------------------------------------------------
" NORMAL MAPS {{{
" ---------------------------------------------------------------------------

" Emacs cancel blasphemy
inoremap <C-G> <Esc>
cnoremap <C-G> <C-C>
xnoremap <C-G> <Esc>

" from tpope's rsi
inoremap <C-A> <C-O>^
inoremap <expr> <C-E> col('.')>strlen(getline('.'))<bar><bar>pumvisible()?"\<Lt>C-E>":"\<Lt>End>"

" expand-o-brackets
inoremap {<Tab> {<CR>}<Esc>O
inoremap {; {<CR>};<Esc>O

" change directories (minor time saver)
nnoremap cd :cd<Space>

" quickly manage buffers
nnoremap gb :ls<CR>:b<Space>
nnoremap gB :ls!<CR>:b<Space>

" resizing windows
noremap <C-Left>  <C-W><
noremap <C-Up>    <C-W>+
noremap <C-Down>  <C-W>-
noremap <C-Right> <C-W>>

" q to quit help {{{
" (from Junegunn's vimrc)
function! s:helpquit()
  if &buftype == 'help'
    nnoremap <buffer> q :bd<CR>
  endif
endfunction
augroup q_for_quit
  au!
  au BufEnter *.txt call s:helpquit()
augroup END
" }}}

" Source vimscript operator {{{
" Nice for quick vimscript testing.
function! s:SourceVimscript(type)
  let sel_save = &selection
  let &selection = "inclusive"
  let reg_save = @"
  if a:type == 'line'
    silent execute "normal! '[V']y"
  elseif a:type == 'char'
    silent execute "normal! `[v`]y"
  elseif a:type == "visual"
    silent execute "normal! gvy"
  elseif a:type == "currentline"
    silent execute "normal! yy"
  endif
  let @" = substitute(@", '\n\s*\\', '', 'g')
  " source the content
  @"
  let &selection = sel_save
  let @" = reg_save
endfunction
" }}}
nnoremap <silent> g: :set opfunc=<SID>SourceVimscript<CR>g@
vnoremap <silent> g: :<C-U>call <SID>SourceVimscript("visual")<CR>
nnoremap <silent> g:: :call <SID>SourceVimscript("currentline")<CR>

" %% for current buffer file name
" :: for current buffer file path
cnoremap %% <C-R>=fnameescape(expand('%'))<CR>
cnoremap :: <C-R>=fnameescape(expand('%:p:h'))<CR>/

" unimpaired.vim inspired
" toggle pastemode
set pastetoggle=cop
" toggle centering the cursor
nnoremap coz :let &scrolloff=999-&scrolloff<CR>:set so?<CR>

" Delete & Replace operator {{{
" (credit to justinmk's init.vim)
" why?
" - repeatable
" - faster/more convenient than visual-replace
" - does not modify ' mark
" - DWIM behavior for linewise => characterwise
func! s:trimws_ml(s) abort "trim whitespace across multiple lines
  return substitute(a:s, '^\_s*\(.\{-}\)\_s*$', '\1', '')
endf
let s:rr_reg = '"'
func! s:set_reg(reg_name) abort
  let s:rr_reg = a:reg_name
endf
func! s:replace_without_yank(type) abort
  let rr_orig = getreg(s:rr_reg, 1) "save registers and types to restore later.
  let rr_type = getregtype(s:rr_reg)
  let ur_orig = getreg('"', 1)
  let ur_type = getregtype('"')
  let sel_save = &selection
  let &selection = "inclusive"
  let replace_curlin = (1==col("'[") && (col('$')==1 || col('$')==(col("']")+1)) && line("'[")==line("']"))

  if a:type ==? 'line' || replace_curlin
    exe "keepjumps normal! '[V']\"".s:rr_reg."p"
  elseif a:type ==? 'block'
    exe "keepjumps normal! `[\<C-V>`]\"".s:rr_reg."p"
  else
    "DWIM: if pasting linewise contents in a _characterwise_ motion, trim
    "      surrounding whitespace from the content to be pasted.
    if rr_type ==# "V"
      call setreg(s:rr_reg, s:trimws_ml(rr_orig), "v")
    endif
    exe "keepjumps normal! `[v`]\"".s:rr_reg."p"
  endif

  let &selection = sel_save
  call setreg('"',      ur_orig, ur_type)
  call setreg(s:rr_reg, rr_orig, rr_type)
endf

" }}}
nnoremap <silent> dr  :<C-u>call <sid>set_reg(v:register)<bar>set opfunc=<sid>replace_without_yank<CR>g@
nnoremap <silent> drr :<C-u>call <sid>set_reg(v:register)<cr>0:<C-u>set opfunc=<sid>replace_without_yank<CR>g@$
" slightly related key-press-saver
xnoremap R "0p

" }}}
" ---------------------------------------------------------------------------
" LEADER MAPS {{{
" ---------------------------------------------------------------------------
" Leader is Space, see STARTUP section

" edit vimrc
nnoremap <silent> <Leader>v :edit $MYVIMRC<CR>
nnoremap <silent> <Leader>V :tabnew $MYVIMRC<CR>

" shortcuts
nnoremap <Leader>f :find<Space>
nnoremap <Leader>s :write<CR>
nnoremap <Leader>h :help<Space>
" :help on the word under the cursor
nnoremap <Leader>H :help <C-R><C-W><CR>

" save my pinky some stress
nnoremap <Leader><Space> :
nnoremap <Leader>w <C-w>

" circular windows
nnoremap <Leader><Tab> <C-W>w

" populate the location list with last search results
" useful for seeing the exact number of matches
nnoremap <Leader>/ :lvim //g %<CR>

" search for all numbers
nnoremap <Leader># /\v\d+<CR>

" search for all brackets
noremap <Leader>{ ?[{}]<CR>
noremap <Leader>} /[{}]<CR>
ounmap <Leader>{
ounmap <Leader>}

" toggle location & quickfix lists {{{
" (from vimwiki)
function! GetBufferList()
  redir =>buflist
  silent! ls!
  redir END
  return buflist
endfunction

function! ToggleList(bufname, pfx)
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      exec(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
    echohl ErrorMsg
    echo "Location List is Empty."
    return
  endif
  let winnr = winnr()
  exec(a:pfx.'open')
  if winnr() != winnr
    wincmd p
  endif
endfunction
" }}}
nnoremap <silent> <Leader>l :call ToggleList("Location List", 'l')<CR>
nnoremap <silent> <Leader>q :call ToggleList("Quickfix List", 'c')<CR>

" alternate between header and source files {{{
" (credit to junegunn's vimrc)
function! s:A()
  let name = expand('%:r')
  let ext = tolower(expand('%:e'))
  let sources = ['c', 'cc', 'cpp', 'cxx']
  let headers = ['h', 'hh', 'hpp', 'hxx']
  for pair in [[sources, headers], [headers, sources]]
    let [set1, set2] = pair
    if index(set1, ext) >= 0
      for h in set2
        let aname = name.'.'.h
        for a in [aname, toupper(aname)]
          if filereadable(a)
            execute 'e' a
            return
          end
        endfor
      endfor
    endif
  endfor
endfunction
command! A call <SID>A()
" }}}
nnoremap <Leader>A :A<CR>

" quick scratch buffer
nnoremap <Leader>S :enew<CR>:setl bt=nofile bh=hide noswf<CR>:set ft=

" copy all to system clipboard
nnoremap \y ggVG"+y

" }}}
" ---------------------------------------------------------------------------

" }}}
" ===========================================================================
" MISCELLANEOUS {{{
" ===========================================================================
" Other functions, commands, settings,
" etc.  that don't fit elsewhere go here

" delete all buffers and open Startify
function! s:RestartVim()
  if exists('g:loaded_startify')
    SClose
  else
    %bdelete
    setl buftype=nofile bufhidden=wipe
  endif
endfunction
command! -bar RestartVim call <SID>RestartVim()

" toggle syntax highlighting
" useful when Vim is crippled by its inefficient highlighting
function! s:ToggleSyntaxHighlighting()
  let s:folds = &foldlevel
  exec 'syntax '.(exists("g:syntax_on") ? 'off' : 'enable')
  let &foldlevel=s:folds
endfunction
command! ToggleSyntax call <SID>ToggleSyntaxHighlighting()

" DoubleView {{{
" Vertically split the current buffer into two windows which will stay
" scroll-bound together.  Allows you to see twice as much as before!
" (disables the wrap setting and expands folds to work better)
" (PS: this is kind of janky, but I like it anyway)
function! s:DoubleView()
  let s:DV_so=&scrolloff
  set scrolloff=0 noscrollbind nowrap nofoldenable
  botright vsplit
  normal! Ljzt
  setl scrollbind
  wincmd p
  setl scrollbind
  let &scrolloff=s:DV_so
endfunction " }}}
command! DoubleView call <SID>DoubleView()

" custom text objects
let s:separators = exists('g:loaded_targets') ? [ '`', '%']
      \ : [ '_', '.', ':', ',', ';', '<bar>', '/', '<bslash>', '*', '+', '%', '`' ]
for char in s:separators
  execute 'xnoremap i' . char . ' :<C-u>normal! T' . char . 'vt' . char . '<CR>'
  execute 'onoremap i' . char . ' :normal vi' . char . '<CR>'
  execute 'xnoremap a' . char . ' :<C-u>normal! F' . char . 'vf' . char . '<CR>'
  execute 'onoremap a' . char . ' :normal va' . char . '<CR>'
endfor

" Clear Trailing White spaces
cabbrev ctw s/\s\+$//e

" }}}
" ===========================================================================
