" vim: set foldmethod=marker foldlevel=0:
" Author: Austin Smith <AssailantLF@gmail.com>
" Source: https://gitlab.com/AssailantLF/dotfiles

" ===========================================================================
" STARTUP {{{
" ===========================================================================

" let s:is_cygwin = has('win32unix') || has('win64unix')
" let s:is_mac = has('gui_macvim') || has('mac')
let s:is_windows = has('win32') || has('win64')
let s:is_nvim = has('nvim')
let s:myvimdir ="~/.vim"
if s:is_windows
  let s:myvimdir ="~/vimfiles"
elseif s:is_nvim
  let s:myvimdir ="~/.config/nvim"
endif

" use Vim settings over obsolescent Vi settings
set nocompatible

" enables filetype detection, ftplugins, and indent files
filetype plugin indent on

" }}}
" ===========================================================================
" VIM-PLUG {{{
" ===========================================================================
" (minimalist plugin manager)

" Install plugins at startup if they aren't installed {{{

if !isdirectory(expand(s:myvimdir . "/plugged"))
  " only inform once!
  if !isdirectory(expand(s:myvimdir . "/autoload/vimrc_booted/"))
    if s:is_windows
      silent exec expand("!mkdir \\%userprofile\\%/vimfiles/autoload/vimrc_booted/")
    else
      exec expand("!mkdir " . s:myvimdir . "/autoload/vimrc_booted")
    endif
    echo "To install plugins (via vim-plug),"
    echo "run :PlugInstall and restart Vim."
  endif
endif

" }}}

call plug#begin()

" PLUGINS

" Tim Pope
Plug 'tpope/vim-surround' " ------------- surroundings manipulation
Plug 'tpope/vim-fugitive' " ------------- Git integration
Plug 'tpope/vim-unimpaired' " ----------- many helpful mappings
Plug 'tpope/vim-commentary' " ----------- easier commenting
Plug 'tpope/vim-speeddating' " ---------- increment dates, times, and more
Plug 'tpope/vim-repeat' " --------------- . repeat for plugins
Plug 'tpope/vim-eunuch' " --------------- UNIX helper commands
Plug 'tpope/vim-rsi' " ------------------ readline style insertion
Plug 'tpope/vim-dispatch' " ------------- asynchronous make
Plug 'tpope/vim-vinegar' " -------------- minor netrw enhancements

" Text Objects
Plug 'kana/vim-textobj-user' " ---------- custom text object plugin
Plug 'kana/vim-textobj-entire' " -------- entire document (ae)
Plug 'kana/vim-textobj-indent' " -------- indent (ai)
Plug 'kana/vim-textobj-function' " ------ function (af)
Plug 'wellle/targets.vim' " ------------- extended, extra text objects

" Appearance/UI
Plug 'justinmk/vim-syntax-extra' " ------ improved C syntax highlighting
Plug 'itchyny/lightline.vim' " ---------- fancy status line
Plug 'mhinz/vim-Startify' " ------------- nice startup screen
Plug 'Yggdroot/indentLine' " ------------ shows indents made of spaces
Plug 'kkoenig/wimproved.vim' " ---------- improvements for Windows UI
Plug 'junegunn/vim-easy-align' " -------- text alignment plugin
Plug 'junegunn/goyo.vim' " -------------- distraction free text editing
Plug 'junegunn/rainbow_parentheses.vim' " rainbow parenthesis

" The Rest
Plug 'mbbill/undotree' " ---------------- visual undo tree
Plug 'justinmk/vim-dirvish' " ----------- vinegar inspired file manager
Plug 'justinmk/vim-gtfo' " -------------- go to file manager or terminal
Plug 'junegunn/gv.vim' " ---------------- view git commits (needs fugitive)
Plug 'tommcdo/vim-exchange' " ----------- easy text exchange for vim
Plug 'mhinz/vim-sayonara' " ------------- sane buffer/window closing
Plug 'ctrlpvim/ctrlp.vim' " ------------- fuzzy file/buffer search
Plug 'ervandew/supertab' " -------------- tab for auto completion
Plug 'Konfekt/FastFold' " --------------- more efficient automatic folding
Plug 'AndrewRadev/switch.vim' " --------- toggle/switch various objects
Plug 'szw/vim-g' " ---------------------- google search from Vim
" Plug 'ludovicchabant/vim-gutentags' " --- automatic tag manager
Plug 'majutsushi/Tagbar' " -------------- view ctags easily
if has('python') || has('python3')
  Plug 'SirVer/UltiSnips' " ------------- snippet plugin
  Plug 'honza/vim-snippets' " ----------- preconfigured snippet package
endif

call plug#end()

" }}}
" ===========================================================================
"  GENERAL SETTINGS {{{
" ===========================================================================

set hidden
set incsearch
set ignorecase
set smartcase
set autoread
set lazyredraw
set gdefault
set showcmd
set vb t_vb=
set sidescroll=8
set backspace=indent,eol,start
set history=10000
set undolevels=100000
set complete=.,w,b,t
set synmaxcol=1024
set nrformats-=octal
set fileformat=unix
set virtualedit=all
set sessionoptions-=options
set sessionoptions-=folds
set path=.,**
if s:is_windows
  set makeprg=build.bat
endif
silent! set mouse=a

" command-line completion settings
set wildmenu
set wildmode=full
set wildignore+=.hg,.git,.svn                    " Version control
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.spl                            " compiled spelling word lists
set wildignore+=*.sw?                            " Vim swap files
set wildignore+=*.DS_Store                       " OSX garbage

" put this useful, ugly junk in a folder
let s:tempdir=expand(s:myvimdir."/stuff")
if !isdirectory(expand(s:tempdir))
  call mkdir(expand(s:tempdir), "p")
endif
set backup
let &backupdir=s:tempdir
set swapfile
let &directory=s:tempdir
if has('persistent_undo')
  set undofile
  let &undodir=s:tempdir
endif

" return to the same line when a file is reopened
augroup line_return
  au!
  au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END

" }}}
" ===========================================================================
"  APPEARANCE AND FORMATTING {{{
" ===========================================================================

syntax on
set laststatus=2
set ruler
" set cursorline
set guioptions=
set t_Co=256
set cpoptions+=$
set splitright
set numberwidth=1
set encoding=utf-8
set autoindent
set smartindent
set foldmethod=syntax
set foldlevel=999
set textwidth=80
set nosmarttab
set linebreak
set listchars=tab:â–¸\ ,trail:â– ,extends:Â»,precedes:Â«
set list
if has('linebreak')
  set showbreak=â†ª
  silent! set breakindent
else
  set listchars+=eol:Â¬
endif

" fallback default colorscheme
colorscheme desert

" my favicolo of all time
let g:badwolf_darkgutter = 1
silent! colorscheme badwolf

" fallback status line if lightline isn't enabled
" (pretty much the same layout as default lightline)
set statusline=%<%f\ %h%m%r%=%y\ %P%8(%l,%v%)\|

" default format options
" see: fo-table for info on flags
set formatoptions=rq1j

" default tab settings
set tabstop=4 softtabstop=0 shiftwidth=4 expandtab

augroup appearance
  au!
  if s:is_windows
    " maximize window in windows
    au GUIEnter * simalt ~x
    set guifont=DejaVu_Sans_Mono:h9
  else
    set guifont=DejaVu\ Sans\ Mono\ 9
  endif
  " resize windows/splits when the window is resized
  au VimResized * :wincmd =
augroup END

" only show in the active buffer/window
augroup active_elements
  au!
  au WinEnter * set cursorline number relativenumber
  au WinLeave * set nocursorline nonumber norelativenumber
  au BufEnter * set cursorline number relativenumber
  au BufLeave * set nocursorline nonumber norelativenumber
augroup END

augroup active_cursorline
  au!
augroup END

" this makes the trailing space indicator invisible
" while typing, otherwise it would drive me crazy
augroup no_trail_in_insert
  au!
  au InsertEnter * :set listchars-=trail:â– 
  au InsertLeave * :set listchars+=trail:â– 
augroup END

" }}}
" ===========================================================================
" KEY MAPPINGS {{{
" ===========================================================================
" anything related to plugins is located
" under its respective PLUGIN SETTINGS section

" ---------------------------------------------------------------------------
" REMAPS OF DEFAULTS {{{
" ---------------------------------------------------------------------------
" it's good to remember these in case I'm stuck with vanilla vi/vim

" disabled
noremap  <F1>    <nop>
inoremap <F1>    <nop>
noremap  <space> <nop>
noremap  <s-cr>  <nop>

" Enter command line mode
noremap <cr> :
" make Enter/CR work normally in quickfix and command-window
augroup enter_correctly
  au!
  au BufReadPost quickfix nnoremap <buffer> <cr> <cr>
  au CmdWinEnter * nnoremap <buffer> <cr> <cr>
augroup END

" go back to last buffer
noremap <backspace> <c-^>

" Y yanks until EOL, more like D and C
" yy still yanks the whole line
nnoremap Y y$

" U as a more sensible redo
nnoremap U <c-r>

" [S]plit line (sister to [J]oin lines) {{{
" cc still changes the whole line
function! s:SplitLine()
  normal i^gk
  silent! substitute/\v +$//
  silent! nohlsearch
  call histdel("search", -1)
  normal $
endfunction
" }}}
nnoremap S :call <sid>SplitLine()<cr>

" visually select the last paste or change
nnoremap gp `[v`]

" going to the exact column is more useful most of the time
nnoremap ` '
nnoremap ' `

" jump list (previous, next)
nnoremap <c-p> <c-o>
nnoremap <c-n> <c-i>

" window management
nnoremap <tab>      <c-w>
nnoremap <s-tab>    <c-w>c
nnoremap <tab><tab> <c-w><c-p>

" easier scrolling (I just prefer not reaching for e and y)
nnoremap <c-j> <c-e>
nnoremap <c-k> <c-y>

" open current file's directory
if !exists("g:loaded_vinegar")
  nnoremap - :e <c-r>=fnameescape(expand('%:p:h'))<cr>/<cr>
endif

" open current working directory
nnoremap + :e .<cr>

" move by wrapped lines instead of line numbers, unless the motion is counted
noremap <expr> j (v:count? 'j' : 'gj')
noremap <expr> k (v:count? 'k' : 'gk')

" { and } skip over closed folds
nnoremap <expr> } foldclosed(search('^$', 'Wn')) == -1 ? "}" : "}j}"
nnoremap <expr> { foldclosed(search('^$', 'Wnb')) == -1 ? "{" : "{k{"

" automatically jump to the end of pasted text
" useful for pasting multi-lines of text
xnoremap p p`]
nnoremap p p`]

" esc to stop inserting in Neovim terminal mode
if s:is_nvim
  tnoremap <esc><esc> <c-\><c-n>
endif

" }}}
" ---------------------------------------------------------------------------
" NORMAL MAPS {{{
" ---------------------------------------------------------------------------

" expand-o-brackets
inoremap {<tab> {<cr>}<esc>O

" change directories (minor time saver)
nnoremap cd :cd<space>

" quickly manage buffers
nnoremap gb :ls<cr>:b<space>
nnoremap gB :ls!<cr>:b<space>

" resizing windows
noremap <c-left>  <c-w><
noremap <c-up>    <c-w>+
noremap <c-down>  <c-w>-
noremap <c-right> <c-w>>

" (go search numbers) search for all numbers
nnoremap <silent> g/# /\v\d+<cr>

" q to quit various things {{{
" (mostly from Junegunn's vimrc)
function! s:helpquit()
  if &buftype == 'help'
    nnoremap <buffer> q :bd<cr>
  endif
endfunction
augroup q_for_quit
  au!
  au BufEnter *.txt call s:helpquit()
  au BufReadPost quickfix nnoremap <buffer> q :bd<cr>
  au FileType netrw nnoremap <buffer> qq :b#<cr>
augroup END
" }}}

" Source vimscript operator {{{
" Nice for quick vimscript testing.
function! SourceVimscript(type)
  let sel_save = &selection
  let &selection = "inclusive"
  let reg_save = @"
  if a:type == 'line'
    silent execute "normal! '[V']y"
  elseif a:type == 'char'
    silent execute "normal! `[v`]y"
  elseif a:type == "visual"
    silent execute "normal! gvy"
  elseif a:type == "currentline"
    silent execute "normal! yy"
  endif
  let @" = substitute(@", '\n\s*\\', '', 'g')
  " source the content
  @"
  let &selection = sel_save
  let @" = reg_save
endfunction
" }}}
nnoremap <silent> g: :set opfunc=SourceVimscript<cr>g@
vnoremap <silent> g: :<c-U>call SourceVimscript("visual")<cr>
nnoremap <silent> g:: :call SourceVimscript("currentline")<cr>

" toggle pastemode (fits well with unimpaired.vim)
set pastetoggle=cop

" Go Continuous Scroll-Binding
" Vertically split the current buffer into two windows which will stay
" scroll-bound together.  Allows you to see twice as much as before!
" (disables the wrap setting and expands folds to work better)
" (PS: this is kind of janky, but I like it anyway)
nnoremap <silent> gcsb :<c-u>let @z=&so<cr>:set so=0 noscb nowrap nofen<cr>:bo vs<cr>Ljzt:setl scb<cr><c-w>p:setl scb<cr>:let &so=@z<cr>

" %% for current buffer file name
" :: for current buffer file path
" (credit to romainl's vimrc)
cnoremap %% <c-r>=fnameescape(expand('%'))<cr>
cnoremap :: <c-r>=fnameescape(expand('%:p:h'))<cr>/

" }}}
" ---------------------------------------------------------------------------
" LEADER MAPS {{{
" ---------------------------------------------------------------------------

" leader the easiest key to reach
let mapleader = "\<space>"

" find a file
nnoremap <leader>f :find<space>

" write file
nnoremap <leader>w :write<cr>

" open vimrc
nnoremap <silent> <leader>v :edit $MYVIMRC<cr>:setl nobl<cr>
nnoremap <silent> <leader>V :tabnew $MYVIMRC<cr>:setl nobl<cr>

" search for brackets
noremap <leader>{ ?[{}]<cr>
noremap <leader>} /[{}]<cr>

" toggle centering the cursor
nnoremap <leader>zz :let &scrolloff=999-&scrolloff<cr>:set so?<cr>

" toggle location & quickfix lists {{{
" (from vimwiki)
function! GetBufferList()
  redir =>buflist
  silent! ls!
  redir END
  return buflist
endfunction

function! ToggleList(bufname, pfx)
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      exec(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
    echohl ErrorMsg
    echo "Location List is Empty."
    return
  endif
  let winnr = winnr()
  exec(a:pfx.'open')
  if winnr() != winnr
    " wincmd p
  endif
endfunction
" }}}
nnoremap <silent> <leader>l :call ToggleList("Location List", 'l')<cr>
nnoremap <silent> <leader>q :call ToggleList("Quickfix List", 'c')<cr>

" Alternate between header and source files {{{
" <leader>A or :A
" (credit to junegunn's vimrc)
function! s:A()
  let name = expand('%:r')
  let ext = tolower(expand('%:e'))
  let sources = ['c', 'cc', 'cpp', 'cxx']
  let headers = ['h', 'hh', 'hpp', 'hxx']
  for pair in [[sources, headers], [headers, sources]]
    let [set1, set2] = pair
    if index(set1, ext) >= 0
      for h in set2
        let aname = name.'.'.h
        for a in [aname, toupper(aname)]
          if filereadable(a)
            execute 'e' a
            return
          end
        endfor
      endfor
    endif
  endfor
endfunction
command! A call <sid>A()
" }}}
nnoremap <leader>A :A<cr>

" }}}
" ---------------------------------------------------------------------------

" }}}
" ===========================================================================
" FUNCTIONS, ABBREVIATIONS, MISC {{{
" ===========================================================================
" mostly miscellaneous

" Reset Vim, delete all buffers and open Startify
function! s:RestartVim()
  if exists('g:loaded_startify')
    SClose
  else
    %bdelete
  endif
endfunction
command! RestartVim call <sid>RestartVim()

" toggle syntax highlighting {{{
function! s:ToggleSyntaxHighlighting()
  let s:folds = &foldlevel
  if exists("g:syntax_on")
    syntax off
  else
    syntax on
  endif
  let &foldlevel=s:folds
endfunction
command! ToggleSyntaxHighlighting call <sid>ToggleSyntaxHighlighting()
" }}}

" Vim 'screensaver' by kssmbi {{{
function! s:RotateString(string)
  let split_string = split(a:string, '\zs')
  return join(split_string[-1:] + split_string[:-2], '')
endfunction

function! s:RotateLine(line, leading_whitespace, trailing_whitespace)
  return substitute(
        \ a:line,
        \ '^\(' . a:leading_whitespace . '\)\(.\{-}\)\(' . a:trailing_whitespace . '\)$',
        \ '\=submatch(1) . <sid>RotateString(submatch(2)) . submatch(3)',
        \ ''
        \ )
endfunction

function! s:RotateLines()
  let saved_view = winsaveview()
  let first_visible_line = line('w0')
  let last_visible_line = line('w$')
  let lines = getline(first_visible_line, last_visible_line)
  let leading_whitespace = map(
        \ range(len(lines)),
        \ 'matchstr(lines[v:val], ''^\s*'')'
        \ )
  let trailing_whitespace = map(
        \ range(len(lines)),
        \ 'matchstr(lines[v:val], ''\s*$'')'
        \ )
  try
    while 1 " <C-c> to exit
      let lines = map(
            \ range(len(lines)),
            \ '<sid>RotateLine(lines[v:val], leading_whitespace[v:val], trailing_whitespace[v:val])'
            \ )
      call setline(first_visible_line, lines)
      redraw
      sleep 50m
    endwhile
  finally
    if &modified
      silent undo
    endif
    call winrestview(saved_view)
  endtry
endfunction
" }}}
command! TheBestThingEver call <sid>RotateLines()

" Clear Trailing White spaces
cabbrev ctw s/\s\+$//e

" ...
augroup top_o_file
 au!
 au BufEnter d*_*y.txt normal! gg
augroup END

" }}}
" ===========================================================================
" PLUGIN SETTINGS {{{
" ===========================================================================
" OCD's beware: arbitrarily sorted list ahead!

" don't load these settings without plugins
if isdirectory(expand(s:myvimdir . "/plugged"))

  " Fugitive {{{
  nnoremap <leader>gs :Gstatus<cr>
  nnoremap <leader>gd :Gdiff<cr>
  nnoremap <leader>gD :Gdiff HEAD<cr>
  nnoremap <leader>gc :Gcommit<cr>
  nnoremap <leader>gl :Git log<cr>
  nnoremap <leader>gp :Git push<cr>
  nnoremap <leader>gw :Gwrite<cr>
  nnoremap <leader>gr :Gremove<cr>
  " }}}

  " Dispatch {{{
  nnoremap <leader>m :Make<cr>
  " }}}

  " Sayonara {{{
  " close buffer
  nnoremap gs :Sayonara<cr>
  " close buffer, but not window
  nnoremap gS :Sayonara!<cr>
  " prompt to close vim when closing the last file
  let g:sayonara_confirm_quit = 1
  " see: 'q to quit' under KEY MAPPINGS/NORMAL MAPS
  function! s:helpquit()
    if &buftype == 'help'
      nnoremap <buffer> q :Sayonara<cr>
    endif
  endfunction
  augroup q_for_quit
    au!
    au BufEnter *.txt call s:helpquit()
    au BufReadPost quickfix nnoremap <buffer> q :Sayonara<cr>
    au FileType netrw nnoremap <buffer> qq :Sayonara!<cr>
  augroup END
  " }}}

  " CtrlP {{{
  " ignore .git folders to speed up searches
  let g:ctrlp_user_command = ['.git/', 'git --git-dir=%s/.git ls-files -oc --exclude-standard']
  let g:ctrlp_max_depth = 15
  " include hidden files
  let g:ctrlp_show_hidden = 1
  " open multiple files in ONE window
  let g:ctrlp_open_multiple_files = '1vr'
  " ctrl-o to open specifically
  let g:ctrlp_arg_map = 1
  " change default CtrlP mapping
  " more like LeaderP amirite hahahahahaHAHWDAQKAJDHKAHKDJwda.
  let g:ctrlp_map = '<leader>p'
  " shortcuts
  nnoremap <leader><c-p> :CtrlP<space>
  nnoremap <leader><c-e> :CtrlPMRUFiles<cr>
  nnoremap <leader><c-l> :CtrlPLine<cr>
  nnoremap <leader>b :CtrlPBuffer<cr>
  " }}}

  " gtfo.vim {{{
  let g:gtfo#terminals = { 'win' : 'C:\WINDOWS\system32\cmd.exe /k' }
  " }}}

  " wimproved.vim {{{
  " toggle fullscreen
  nnoremap <F11> :WToggleFullscreen<cr>
  augroup wimproved
    au!
    autocmd GUIEnter * silent! WToggleClean
  augroup END
  " }}}

  " Goyo {{{
  " toggle Goyo (distraction free editing)
  nnoremap <leader>G :Goyo<cr>
  " }}}

  " vim-easy-align {{{
  " Start interactive EasyAlign in visual mode (e.g. vipga)
  vmap ga <Plug>(EasyAlign)
  " Start interactive EasyAlign for a motion/text object (e.g. gaip)
  nmap ga <Plug>(EasyAlign)
  " }}}

  " indentLine {{{
  nnoremap <leader>i :IndentLinesToggle<cr>
  " disable by default
  let g:indentLine_enabled = 1
  " enable for certain filetypes
  let g:indentLine_fileType = ['c', 'cpp']
  " }}}

  " switch.vim {{{
  let g:switch_mapping = "<leader>s"
  "}}}

  " undotree {{{
  nnoremap <leader>u :UndotreeToggle<cr>
  function g:Undotree_CustomMap()
    nunmap <buffer> <Tab>
  endfunc
  " }}}

  " Tagbar {{{
  nnoremap <leader>t :TagbarToggle<cr>
  " }}}

  " Dirvish {{{
  let g:dirvish_hijack_netrw = 0
  " open current file's directory
  nnoremap <silent> - :Dirvish %<cr>
  " open current working directory
  nnoremap <silent> + :Dirvish<cr>
  " direct shortcut
  nnoremap <leader>d :Dirvish<space>
  augroup my_dirvish_events
    autocmd!
    " I use <cr> to enter cmdline mode,
    " so use o to open
    autocmd FileType dirvish
          \ nnoremap <buffer> <cr> :
          \|xnoremap <buffer> <cr> :
          \|nnoremap <buffer> o :call dirvish#open("edit", 0)<CR>
          \|xnoremap <buffer> o :call dirvish#open("edit", 0)<CR>
          \|nnoremap <buffer> h :call dirvish#open("split", 0)<CR>
          \|xnoremap <buffer> h :call dirvish#open("split", 0)<CR>
          \|nnoremap <buffer> l :call dirvish#open("vsplit", 0)<CR>
          \|xnoremap <buffer> l :call dirvish#open("vsplit", 0)<CR>
    " map gh to hide "hidden" files.
    autocmd FileType dirvish nnoremap <buffer> gh
          \ :g@\v/\.[^\/]+/?$@d<cr>
  augroup END
  " }}}

  " Rainbow Parenthesis {{{
  " filetypes will be added and removed as needed
  augroup rainbow_filetypes
    autocmd!
    autocmd FileType c,cpp,vim,sh,dosbatch RainbowParentheses
  augroup END
  " }}}

  " Startify {{{
  augroup startify_maps
    au!
    " I use <cr> to enter command line mode,
    " so use o to open files instead.
    au User Startified unmap <buffer> <cr>
    au User Startified nmap <buffer> o <Plug>(startify-open-buffers)
    au User Startified setlocal relativenumber number
  augroup END
  let g:ctrlp_reuse_window = 'startify'
  let g:startify_files_number = 5
  let g:startify_session_delete_buffers = 1
  let g:startify_session_persistence = 1
  let g:startify_custom_header = [
        \ '                                                                            ',
        \ '       ___________________________                                          ',
        \ '      /                           \                                         ',
        \ '      |     VIM - Vi IMproved     |                                         ',
        \ '      |    -------------------    |                                         ',
        \ '      |  by Bram Moolenaar et al. |                                         ',
        \ '      \__________________   ______/            __----~~~~~~~~~~~------___   ',
        \ '                         \ /        .  .   ~~//====......          __--~ ~~ ',
        \ '                    -.    \\      \_|//     |||\\  ~~~~~~::::... /~         ',
        \ '                 ___-==_   \   _-~o~  \/    |||  \\            _/~~-        ',
        \ '         __---~~~.==~||\=_    -_--~/_-~|-   |\\   \\        _/~             ',
        \ '     _-~~     .=~    |  \\-_    ''-~7  /-   /  ||    \      /               ',
        \ '   .~       .~       |   \\ -_    /  /-   /   ||      \   /                 ',
        \ '  /  ____  /         |     \\ ~-_/  /|- _/   .||       \ /                  ',
        \ '  |~~    ~~|--~~~~--_ \     ~==-/   | \~--===~~        .\                   ',
        \ '           ''         ~-|      /|    |-~\~~       __--~~                    ',
        \ ] " Thanks http://www.asciiworld.com
  " }}}

  " lightline {{{
  nnoremap <silent> <leader>L }:exec lightline#toggle()<cr>``
  " compatibility with other plugins {{{
  let g:lightline = {
        \ 'colorscheme': 'powerline',
        \ 'active': {
        \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
        \   'right': [ [ 'syntastic', 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
        \ },
        \ 'component_function': {
        \   'fugitive': 'LightLineFugitive',
        \   'filename': 'LightLineFilename',
        \   'fileformat': 'LightLineFileformat',
        \   'filetype': 'LightLineFiletype',
        \   'fileencoding': 'LightLineFileencoding',
        \   'mode': 'LightLineMode',
        \   'ctrlpmark': 'CtrlPMark',
        \ },
        \ 'component_expand': {
        \   'syntastic': 'SyntasticStatuslineFlag',
        \ },
        \ 'component_type': {
        \   'syntastic': 'error',
        \ },
        \ 'subseparator': { 'left': '|', 'right': '|' }
        \ }

  function! LightLineModified()
    return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
  endfunction

  function! LightLineReadonly()
    return &ft !~? 'help' && &readonly ? 'RO' : ''
  endfunction

  function! LightLineFilename()
    let fname = expand('%:t')
    return fname == 'ControlP' ? g:lightline.ctrlp_item :
          \ fname == '__Tagbar__' ? g:lightline.fname :
          \ fname =~ '__Gundo\|NERD_tree' ? '' :
          \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
          \ &ft == 'unite' ? unite#get_status_string() :
          \ &ft == 'vimshell' ? vimshell#get_status_string() :
          \ ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
          \ ('' != fname ? fname : '[No Name]') .
          \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
  endfunction

  function! LightLineFugitive()
    try
      if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
        let mark = ''  " edit here for cool mark
        let _ = fugitive#head()
        return strlen(_) ? mark._ : ''
      endif
    catch
    endtry
    return ''
  endfunction

  function! LightLineFileformat()
    return winwidth(0) > 70 ? &fileformat : ''
  endfunction

  function! LightLineFiletype()
    return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
  endfunction

  function! LightLineFileencoding()
    return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
  endfunction

  function! LightLineMode()
    let fname = expand('%:t')
    return fname == '__Tagbar__' ? 'Tagbar' :
          \ fname == 'ControlP' ? 'CtrlP' :
          \ fname == '__Gundo__' ? 'Gundo' :
          \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
          \ winwidth(0) > 60 ? lightline#mode() : ''
  endfunction

  function! CtrlPMark()
    if expand('%:t') =~ 'ControlP'
      call lightline#link('iR'[g:lightline.ctrlp_regex])
      return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
            \ , g:lightline.ctrlp_next], 0)
    else
      return ''
    endif
  endfunction

  let g:ctrlp_status_func = {
        \ 'main': 'CtrlPStatusFunc_1',
        \ 'prog': 'CtrlPStatusFunc_2',
        \ }

  function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
    let g:lightline.ctrlp_regex = a:regex
    let g:lightline.ctrlp_prev = a:prev
    let g:lightline.ctrlp_item = a:item
    let g:lightline.ctrlp_next = a:next
    return lightline#statusline(0)
  endfunction

  function! CtrlPStatusFunc_2(str)
    return lightline#statusline(0)
  endfunction

  let g:tagbar_status_func = 'TagbarStatusFunc'

  function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
    return lightline#statusline(0)
  endfunction
  " }}}}
  " }}}

endif

" }}}
" ===========================================================================
